#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

/**
 * Recursively scans a directory for .md and .mdx files
 * @param {string} dirPath - Directory to scan
 * @param {string} basePath - Base path for relative file paths
 * @returns {Array} Array of file paths or nested group objects
 */
function scanDirectory(dirPath, basePath = '') {
  try {
    const items = fs.readdirSync(dirPath, { withFileTypes: true });
    const result = [];
    const files = [];
    const dirs = [];

    // Separate files and directories
    for (const item of items) {
      if (item.name.startsWith('.') || item.name.startsWith('_')) {
        continue; // Skip hidden/special files
      }

      if (item.isFile()) {
        if (item.name.endsWith('.mdx') || item.name.endsWith('.md')) {
          const fileName = item.name.replace(/\.(mdx|md)$/, '');
          const filePath = basePath ? `${basePath}/${fileName}` : fileName;
          files.push({ name: fileName, path: filePath, isIndex: fileName === 'index' });
        }
      } else if (item.isDirectory()) {
        dirs.push(item.name);
      }
    }

    // Sort files alphabetically, but put index first
    files.sort((a, b) => {
      if (a.isIndex && !b.isIndex) return -1;
      if (!a.isIndex && b.isIndex) return 1;
      return a.name.localeCompare(b.name);
    });

    // Add files to result
    for (const file of files) {
      result.push(file.path);
    }

    // Sort directories alphabetically
    dirs.sort();

    // Add subdirectories as groups
    for (const dir of dirs) {
      const subDirPath = path.join(dirPath, dir);
      const subBasePath = basePath ? `${basePath}/${dir}` : dir;
      const subItems = scanDirectory(subDirPath, subBasePath);
      
      if (subItems.length > 0) {
        // Convert directory name to proper label (handle kebab-case, etc.)
        const groupLabel = dir
          .split('-')
          .map(word => word.charAt(0).toUpperCase() + word.slice(1))
          .join(' ');
        
        result.push({
          group: groupLabel,
          pages: subItems
        });
      }
    }

    return result;
  } catch (error) {
    console.warn(`Warning: Could not scan directory ${dirPath}:`, error.message);
    return [];
  }
}

/**
 * Main function to scan all autogenerated directories
 */
function generateAutoPages() {
  const docsDir = path.join(__dirname, 'docs');
  const autoGenDirs = [
    'universal-gateway/examples',
    'traffic-policy/getting-started',
    'traffic-policy/concepts', 
    'traffic-policy/actions',
    'traffic-policy/variables',
    'traffic-policy/examples',
    'agent-sdks',
    'guides/device-gateway',
    'guides/identity-aware-proxy',
    'using-ngrok-with',
    'integrations'
  ];

  const results = {};

  for (const dirName of autoGenDirs) {
    const fullPath = path.join(docsDir, dirName);
    console.log(`Scanning ${dirName}...`);
    
    if (fs.existsSync(fullPath)) {
      const pages = scanDirectory(fullPath, dirName);
      results[dirName] = pages;
      console.log(`  Found ${pages.length} items`);
    } else {
      console.warn(`  Directory not found: ${fullPath}`);
      results[dirName] = [];
    }
  }

  return results;
}

/**
 * Update docs.json with the proper sidebar-example.js structure
 */
function updateDocsJson() {
  const docsJsonPath = path.join(__dirname, 'docs', 'docs.json');
  const autoPages = generateAutoPages();
  
  // Create the proper Mintlify navigation structure based on sidebar-example.js
  const navigation = [
    // Root level pages (from original sidebar)
    "overview/index",
    "what-is-ngrok",
    "how-ngrok-works", 
    "why-ngrok",
    "whats-new",
    
    // Pricing & Limits group
    {
      "group": "Pricing & Limits",
      "pages": [
        "pricing-limits/index",
        "pricing-limits/free-plan-limits",
        "pricing-limits/traffic-policy-unit-pricing"
      ]
    },
    
    // Getting Started tab
    {
      "tab": "Getting Started", 
      "groups": [
        {
          "group": "Agent CLI",
          "pages": ["getting-started/index"]
        },
        {
          "group": "Cloud Endpoints", 
          "pages": ["getting-started/cloud-endpoints-quickstart"]
        },
        {
          "group": "SDKs",
          "pages": [
            "getting-started/javascript",
            "getting-started/go", 
            "getting-started/python",
            "getting-started/rust"
          ]
        },
        {
          "group": "Kubernetes",
          "pages": [
            "getting-started/kubernetes/ingress",
            "getting-started/kubernetes/gateway-api",
            "getting-started/kubernetes/crds", 
            "getting-started/kubernetes/endpoints"
          ]
        }
      ]
    },
    
    // Universal Gateway tab  
    {
      "tab": "Universal Gateway",
      "groups": [
        {
          "group": "Overview", 
          "pages": ["universal-gateway/overview"]
        },
        {
          "group": "Concepts",
          "pages": [
            {
              "group": "Domains",
              "pages": [
                "universal-gateway/domains",
                "universal-gateway/custom-domains"
              ]
            },
            "universal-gateway/tcp-addresses",
            "universal-gateway/tls-certificates",
            "universal-gateway/edges"
          ]
        },
        {
          "group": "Endpoints", 
          "pages": [
            "universal-gateway/endpoints",
            {
              "group": "Types",
              "pages": [
                "universal-gateway/types",
                {
                  "group": "Cloud Endpoints", 
                  "pages": [
                    "universal-gateway/cloud-endpoints/index",
                    "universal-gateway/cloud-endpoints/change-domain-endpoint",
                    {
                      "group": "Forwarding Traffic",
                      "pages": [
                        "universal-gateway/cloud-endpoints/forwarding-and-load-balancing",
                        "universal-gateway/cloud-endpoints/routing-and-policy-decentralization"
                      ]
                    }
                  ]
                },
                "universal-gateway/agent-endpoints"
              ]
            },
            {
              "group": "Protocols",
              "pages": [
                "universal-gateway/protocols",
                "universal-gateway/http", 
                "universal-gateway/tls",
                "universal-gateway/tcp"
              ]
            },
            {
              "group": "Bindings",
              "pages": [
                "universal-gateway/bindings",
                "universal-gateway/public-endpoints",
                "universal-gateway/internal-endpoints", 
                "universal-gateway/kubernetes-endpoints"
              ]
            },
            {
              "group": "Pooling",
              "pages": [
                "universal-gateway/endpoint-pooling",
                "universal-gateway/load-balancing-multiple-clouds"
              ]
            }
          ]
        },
        {
          "group": "Network",
          "pages": [
            "universal-gateway/global-load-balancer",
            "universal-gateway/tls-termination",
            "universal-gateway/ddos-protection",
            "universal-gateway/ip-addresses",
            "universal-gateway/points-of-presence"
          ]
        },
        {
          "group": "Examples", 
          "pages": [
            "universal-gateway/examples",
            ...autoPages['universal-gateway/examples']
          ]
        }
      ]
    },
    
    // Traffic Policy tab
    {
      "tab": "Traffic Policy",
      "groups": [
        {
          "group": "Overview",
          "pages": ["traffic-policy/index"]
        },
        {
          "group": "Getting Started",
          "pages": autoPages['traffic-policy/getting-started']
        },
        {
          "group": "Concepts", 
          "pages": autoPages['traffic-policy/concepts']
        },
        {
          "group": "Actions",
          "pages": autoPages['traffic-policy/actions']
        },
        {
          "group": "Macros",
          "pages": ["traffic-policy/macros/index"]
        },
        {
          "group": "Secrets",
          "pages": ["traffic-policy/secrets"]
        },
        {
          "group": "Variables",
          "pages": autoPages['traffic-policy/variables']
        },
        {
          "group": "Resources", 
          "pages": ["traffic-policy/identities"]
        },
        {
          "group": "Examples",
          "pages": autoPages['traffic-policy/examples']
        }
      ]
    },
    
    // Continue with other tabs...
    // [Additional tabs would follow the same pattern]
  ];

  // Read current docs.json
  const currentDocs = JSON.parse(fs.readFileSync(docsJsonPath, 'utf8'));
  
  // Update navigation
  currentDocs.navigation = navigation;
  
  // Write back to file
  fs.writeFileSync(docsJsonPath, JSON.stringify(currentDocs, null, 2));
  console.log('\n‚úÖ docs.json updated successfully!');
}

// Run if called directly
if (require.main === module) {
  console.log('üîç Scanning autogenerated directories...\n');
  updateDocsJson();
  
  console.log('\nüìä Auto-generated pages summary:');
  const results = generateAutoPages();
  for (const [dir, pages] of Object.entries(results)) {
    console.log(`  ${dir}: ${pages.length} items`);
  }
}

module.exports = { scanDirectory, generateAutoPages, updateDocsJson };
