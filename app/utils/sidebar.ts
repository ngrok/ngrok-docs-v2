import fs from "fs/promises";
import path from "path";
import { getSidebarItemAtPath } from "./getSidebarData";
import { navData } from "./navData";
import remarkHeadings from "@vcarl/remark-headings";
import { remark } from "remark";
import remarkFrontmatter from "remark-frontmatter";
import remarkParseFrontmatter from "remark-parse-frontmatter";
import { getFullUrlPath } from "./pathSanitization";

export async function getItemsFromDir(dirName: string, bucketLabel: string = "") {
  const remixPathString = "./app/routes/docs+";
  const adjustedDirName = dirName.endsWith("+") ? dirName : `${dirName}+`;
  const itemsDir = path.join(process.cwd(), remixPathString, adjustedDirName);
  const itemsList = [];

  try {
    const dir = await fs.opendir(itemsDir);
    for await (const dirent of dir) {
      const entity = path.join(itemsDir, dirent.name);
      const isFile = (await fs.lstat(entity)).isFile();
      if (!isFile) {
        const indexFilePath = path.join(
          `${dirName}+/`,
          `${dirent.name}/`,
          "index"
        );
        const indexFileData = await getSidebarItemAtPath(indexFilePath);

        if (!indexFileData) {
          // console.error(
          //   `Error getting autogenerated items from dir ${dirName}:`,
          //   `No index file found at ${indexFilePath}`
          // );
          continue;
        }

        const childPath = path.join(`${dirName}+/`, dirent.name);

        const children: any[] | any = await getItemsFromDir(
          path.join(`${dirName}+/`, dirent.name)
        );

        const filteredChildren = children?.filter(
          (item: any) => item?.path && !item?.path?.includes("index")
        );

        itemsList.push({
          title:
            indexFileData.frontmatter?.title ||
            indexFileData.headings[0]?.value,
          bucketLabel,
          path: getFullUrlPath(indexFileData.path),
          children: filteredChildren,
          collapsible: filteredChildren.length > 0,
        });
        continue;
      }

      let markdown = await fs.readFile(entity, "utf8");

      const fileOfRemark: any = remark()
        .use(remarkFrontmatter, ["yaml", "toml"])
        .use(remarkParseFrontmatter)
        .use(remarkHeadings)
        .processSync(markdown);

      itemsList.push({
        path: getFullUrlPath(`/docs/${dirName}/${dirent.name}`),
        bucketLabel,
        title:
          fileOfRemark.data?.frontmatter?.title ||
          fileOfRemark.data?.headings?.find((item: any) => item.depth === 1)
            ?.value,
        children: [],
      });
    }
  } catch (error) {
    // console.error(
    //   `Error getting autogenerated items from dir ${dirName}:`,
    //   error
    // );
  }

  return itemsList;

  // return integrationList.sort((a, b) => a.name.localeCompare(b.name));
}

export type SidebarItem = {
  title?: string;
  bucketLabel: string;
  path?: string;
  children?: SidebarItem[];
  divider?: boolean;
  collapsible?: boolean;
};
const getItemFromString = async (
  itemPath: string, bucketLabel: string = ""
): Promise<SidebarItem | null> => {
  const data = await getSidebarItemAtPath(itemPath);
  if (!data) {
    throw new Error(`No file found for sidebar item: ${itemPath}`);
  }

  return {
    path: data.path,
    bucketLabel,
    title:
      data.frontmatter?.title ||
      data.headings.find((item: any) => item.depth === 1)?.value,
    children: [],
  };
};

const getChildrenData = async (childItems: any, bucketLabel: string = "") => {
  return Promise.allSettled(
    childItems.map(async (child: string | any) => {
      const childType = typeof child;
      switch (childType) {
        case "string":
          return await getItemFromString(child, bucketLabel);
        case "object":
          if (child?.type === "autogenerated") {
            return await getItemsFromDir(child.dirName, bucketLabel);
          }
          return await getItemFromObject(child, bucketLabel);
      }
    })
  );
};

const getItemFromObject = async (itemData: any, bucketLabel: string = "") => {
  const path = itemData?.link?.id
    ? "/docs/" + itemData.link.id.split("/index")[0]
    : null;
  const childrenData = await getChildrenData(
    itemData.items,
    bucketLabel
  );

  return {
    title: itemData.label,
    bucketLabel: bucketLabel,
    path,
    // children: [],
    children: !itemData.items
      ? []
      : childrenData.map((item: any) => item.value).flat(),
    collapsible:
      itemData.collapsible !== undefined
        ? itemData.collapsible
        : true,
  };
};

/**
 * Make this just work if the item is formatted properly already
 */
export const getSidebar = async () => {
  return Promise.allSettled(
    navData.map(async (topLevelBucket: any) => {
      if (typeof topLevelBucket !== "object") throw new Error("Top-level nav item must be an object");
      return await getItemFromObject(topLevelBucket, topLevelBucket.label);
    })
  );
};

function findInNestedArray(arr: any, path: string) {
  if(!arr) return null;
  const pathKey = "path";
  for (const item of arr) {
    // Match found
    if(!item){
      console.log("Item is null or undefined", path, item);
    }
    if(!item || !item[pathKey]){
      console.log("Item has no path property", item);
      continue; // Skip if no path
    }
    if (item[pathKey] === path) {
      return item;
    }

    const childKey = "children";
    // Recurse if children exist and are an array
    if (Array.isArray(item[childKey])) {
      const found: SidebarItem = findInNestedArray(item[childKey], path);
      if (found) {
        return found;
      }
    }
  }

  return null; // Not found
}

export const getActiveNavBucket = (windowPath: string, sidebarData: SidebarItem[]) => {
  // First check if the window path is one of the top-level pages
  const topLevelPage =  sidebarData.find((item: SidebarItem) => item.path === windowPath)
  if(topLevelPage) return topLevelPage;

  // If not, find the first bucket that has a child with the current path
  return sidebarData.find((bucket: SidebarItem) => {
    return findInNestedArray(bucket.children, windowPath);
  }) || null;
}
