import fs from "fs/promises";
import path from "path";
import { getSidebarItemAtPath } from "./getSidebarData";
import { navData } from "./navData";
import remarkHeadings from "@vcarl/remark-headings";
import { remark } from "remark";
import remarkFrontmatter from "remark-frontmatter";
import remarkParseFrontmatter from "remark-parse-frontmatter";
import { getFullUrlPath } from "./pathSanitization";

export async function getItemsFromDir(dirName: string) {
  const remixPathString = "./app/routes/docs+";
  const adjustedDirName = dirName.endsWith("+") ? dirName : `${dirName}+`;
  const itemsDir = path.join(process.cwd(), remixPathString, adjustedDirName);
  const itemsList = [];

  try {
    const dir = await fs.opendir(itemsDir);
    for await (const dirent of dir) {
      const entity = path.join(itemsDir, dirent.name);
      const isFile = (await fs.lstat(entity)).isFile();
      if (!isFile) {
        const indexFilePath = path.join(
          `${dirName}+/`,
          `${dirent.name}/`,
          "index"
        );
        const indexFileData = await getSidebarItemAtPath(indexFilePath);

        if (!indexFileData) {
          // console.error(
          //   `Error getting autogenerated items from dir ${dirName}:`,
          //   `No index file found at ${indexFilePath}`
          // );
          continue;
        }

        const childPath = path.join(`${dirName}+/`, dirent.name);

        const children: any[] | any = await getItemsFromDir(
          path.join(`${dirName}+/`, dirent.name)
        );

        const filteredChildren = children?.filter(
          (item: any) => item?.path && !item?.path?.includes("index")
        );

        itemsList.push({
          title:
            indexFileData.frontmatter?.title ||
            indexFileData.headings[0]?.value,
          path: getFullUrlPath(indexFileData.path),
          children: filteredChildren,
          collapsible: filteredChildren.length > 0,
        });
        continue;
      }

      let markdown = await fs.readFile(entity, "utf8");

      const fileOfRemark: any = remark()
        .use(remarkFrontmatter, ["yaml", "toml"])
        .use(remarkParseFrontmatter)
        .use(remarkHeadings)
        .processSync(markdown);

      itemsList.push({
        path: getFullUrlPath(`/docs/${dirName}/${dirent.name}`),
        title:
          fileOfRemark.data?.frontmatter?.title ||
          fileOfRemark.data?.headings?.find((item: any) => item.depth === 1)
            ?.value,
        children: [],
      });
    }
  } catch (error) {
    // console.error(
    //   `Error getting autogenerated items from dir ${dirName}:`,
    //   error
    // );
  }

  return itemsList;

  // return integrationList.sort((a, b) => a.name.localeCompare(b.name));
}

export type SidebarItem = {
  title?: string;
  path?: string;
  children?: SidebarItem[];
  divider?: boolean;
  collapsible?: boolean;
};
const getItemFromString = async (
  itemPath: string
): Promise<SidebarItem | null> => {
  const data = await getSidebarItemAtPath(itemPath);
  if (!data) {
    throw new Error(`No file found for sidebar item: ${itemPath}`);
  }

  return {
    path: data.path,
    title:
      data.frontmatter?.title ||
      data.headings.find((item: any) => item.depth === 1)?.value,
    children: [],
  };
};

const getChildrenData = async (childItems: any, parentPath: string | null) => {
  return Promise.allSettled(
    childItems.map(async (child: string | any) => {
      const childType = typeof child;
      switch (childType) {
        case "string":
          return await getItemFromString(child);
        case "object":
          if (child?.type === "autogenerated") {
            return await getItemsFromDir(child.dirName);
          }
          return await getItemFromObject(child);
      }
    })
  );
};

const getItemFromObject = async (docusaurusObject: any) => {
  const path = docusaurusObject?.link?.id
    ? "/docs/" + docusaurusObject.link.id.split("/index")[0]
    : null;
  const childrenData = await getChildrenData(
    docusaurusObject.items,
    // dirName applies to items with autogenerated children
    path || docusaurusObject?.dirName
  );

  return {
    title: docusaurusObject.label,
    path,
    // children: [],
    children: !docusaurusObject.items
      ? []
      : childrenData.map((item: any) => item.value).flat(),
    collapsible:
      docusaurusObject.collapsible !== undefined
        ? docusaurusObject.collapsible
        : true,
  };
};

/**
 * Make this just work if the item is formatted properly already
 */
export const getSidebar = async () => {
  return Promise.allSettled(
    navData.map(async (navItem: any) => {
      if (typeof navItem === "string") {
        return await getItemFromString(navItem);
      }
      return await getItemFromObject(navItem);
    })
  );
};
