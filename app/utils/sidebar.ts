import fs from "fs/promises";
import path from "path";
import { getSidebarItemAtPath } from "./getSidebarData";
import { navData } from "./navData";
import remarkHeadings from "@vcarl/remark-headings";
import { remark } from "remark";
import remarkFrontmatter from "remark-frontmatter";
import remarkParseFrontmatter from "remark-parse-frontmatter";
import { getFullUrlPath } from "./pathSanitization";

/**
 * If no index data, path, title, etc can be pulled from the parent object
 */

export async function getItemsFromDir(dirName: string, bucketLabel: string = "", isAutoGenerated: boolean = true) {  
  const remixPathString = "./app/routes/docs+";
  const pathWithPlusesInside = dirName.replaceAll("/", "+/");
  const adjustedDirName = pathWithPlusesInside.endsWith("+") ?
    pathWithPlusesInside : `${pathWithPlusesInside}+`;
  const itemsDir = path.join(process.cwd(), remixPathString, adjustedDirName);
  const itemsList = [];

  try {
    const dir = await fs.opendir(itemsDir);
    for await (const dirent of dir) {
			if (dirent.name === "shared") {
				// Skip the shared directory
        continue;
			}
      const entity = path.join(itemsDir, dirent.name);
      const isFile = (await fs.lstat(entity)).isFile();
      if (!isFile) {   
        const indexFilePath = path.join(
          `${dirName}+/`,
          `${dirent.name}+/`,
          "index"
        );
        const indexFileData = await getSidebarItemAtPath(indexFilePath);
        
        const children: any[] | any = await getItemsFromDir(
          path.join(`${dirName}+`, dirent.name)
        );

        const filteredChildren = children?.filter(
          (item: any) => item?.path && !item?.path?.includes("index")
        );

        itemsList.push({
          title: !indexFileData ? null :
            indexFileData.frontmatter?.sidebar_label ||
            indexFileData.frontmatter?.title ||
            indexFileData.headings[0]?.value,
          bucketLabel,
          path: !indexFileData ? null : getFullUrlPath(indexFileData.path),
          children: filteredChildren,
          isAutoGenerated,
        });
        continue;
      }
     
      if(!dirent.name.endsWith(".md") && !dirent.name.endsWith(".mdx")) {
        // Skip non-md/mdx files
        continue;
      }
      
      let markdown = await fs.readFile(entity, "utf8");

      const fileOfRemark: any = remark()
        .use(remarkFrontmatter, ["yaml", "toml"])
        .use(remarkParseFrontmatter)
        .use(remarkHeadings)
        .processSync(markdown);

      itemsList.push({
        path: getFullUrlPath(`/docs/${dirName}/${dirent.name}`),
        bucketLabel,
        title:
          fileOfRemark.data?.frontmatter?.sidebar_label ||
          fileOfRemark.data?.frontmatter?.title ||
          fileOfRemark.data?.headings?.find((item: any) => item.depth === 1)
            ?.value,
        children: [],
          isAutoGenerated,
      });
    }
  } catch (error) {
    console.error(
      `Error getting autogenerated items from dir ${dirName}:`,
      error
    );
  }
  
      
      if(dirName === "traffic-policy/getting-started") {
        console.log("\n====================");
        console.log("Looking in tp getting started dir", itemsList);
        console.log("====================\n");
      }
  return itemsList;

  // return integrationList.sort((a, b) => a.name.localeCompare(b.name));
}

export type SidebarItemData = {
  title: string;
  bucketLabel: string;
  path?: string;
  children?: SidebarItemData[];
  isAutoGenerated?: boolean;
};
const getItemFromString = async (
  itemPath: string, bucketLabel: string = ""
): Promise<SidebarItemData | null> => {
  const data = await getSidebarItemAtPath(itemPath);
  if (!data) {
    throw new Error(`No file found for sidebar item: ${itemPath}`);
  }

  return {
    path: data.path,
    bucketLabel,
    title:
      data.frontmatter?.sidebar_label ||
      data.frontmatter?.title ||
      data.headings.find((item: any) => item.depth === 1)?.value,
    children: [],
  };
};

const getChildrenData = async (childItems: any, bucketLabel: string = "") => {
  return Promise.allSettled(
    childItems.map(async (child: string | any) => {
      const childType = typeof child;
      switch (childType) {
        case "string":
          return await getItemFromString(child, bucketLabel);
        case "object":
          if (child?.type === "autogenerated") {      
            return await getItemsFromDir(child.dirName, bucketLabel);
          }
          return await getItemFromObject(child, bucketLabel);
      }
    })
  );
};

const getItemFromObject = async (itemData: any, bucketLabel: string = "") => {
  let path = "";
  switch(itemData.type) {
    case "link":
      path = itemData?.href || null;
      break;
    default: // "doc" or "category"
      const id = itemData?.link?.id || itemData?.id;
      if(id){
        path = `/docs/${id.split("/index")[0]}`;
      }
      break;
  }
    
  const childrenData = itemData.items ? await getChildrenData(
    itemData.items,
    bucketLabel
  ) : null;

  const children = childrenData?.map((item: any) => item.value).flat();

  return {
    title: itemData.label,
    bucketLabel,
    path: path || children?.[0]?.path || "",
    children,
  };
};

/**
 * Make this just work if the item is formatted properly already
 */
export const getSidebar = async () => {
  return Promise.allSettled(
    navData.map(async (topLevelBucket: any) => {
      if (typeof topLevelBucket !== "object") throw new Error("Top-level nav item must be an object");
      return await getItemFromObject(topLevelBucket, topLevelBucket.label);
    })
  );
};

function findInNestedArray(arr: any, path: string) {
  if(!arr) return null;
  for (const item of arr) {
    if(!item){
      // console.log("Item is null or undefined", path, item);
      continue;
    }

    if(item["path"]){
      if (path === item["path"] || path === `${item["path"]}/`) {
        return item;
      }
    }
    // Recurse if children `ex`ist and are an array
    if (Array.isArray(item["children"])) {
      const found: SidebarItemData = findInNestedArray(item["children"], path);
      if (found) {
        return found;
      }
    }
  }

  return null;
}

export const getActiveNavBucket = (windowPath: string, sidebarData: SidebarItemData[]) => {
  // First check if the window path is one of the top-level pages
  const topLevelPage =  sidebarData.find((item: SidebarItemData) => item.path === windowPath)
  if(topLevelPage) return topLevelPage;

  // If not, find the first bucket that has a child with the current path
  return sidebarData.find((bucket: SidebarItemData) => {
    return findInNestedArray(bucket.children, windowPath);
  }) || null;
}
