import fs from "fs/promises";
import path from "path";
import { getSidebarItemAtPath } from "./getSidebarData";
import { docusaurusSidebar } from "./docusaurusSidebar";
import remarkHeadings from "@vcarl/remark-headings";
import { remark } from "remark";
import remarkFrontmatter from "remark-frontmatter";
import remarkParseFrontmatter from "remark-parse-frontmatter";
import { getFullUrlPath } from "./pathSanitization";

export async function getItemsFromDir(dirName: string) {
  const remixPathString = "./app/routes/docs+";
  const itemsDir = path.join(process.cwd(), remixPathString, `${dirName}+/`);
  const itemsList = [];

  try {
    const dir = await fs.opendir(itemsDir);
    for await (const dirent of dir) {
      const entity = path.join(itemsDir, dirent.name);
      const isFile = (await fs.lstat(entity)).isFile();
      let children = [];
      if (!isFile) {
        /**
         * 1. Read the index file and apply its path and title to this item
         * 2. Read the other children and add them as children
         */
        console.log("Dirname", dirName, "dirent", dirent.name);
        const indexFilePath = path.join(
          `${dirName}+/`,
          `${dirent.name}/`,
          "index"
        );
        const indexFileData = await getSidebarItemAtPath(indexFilePath);

        const childPath = path.join(`${dirName}+/`, dirent.name);
        console.log("Child path", childPath);
        const result = {
          title:
            indexFileData?.frontmatter?.title ||
            indexFileData?.headings[0]?.value,
          path: indexFileData?.path,
          children: await getItemsFromDir(
            path.join(`${dirName}+/`, dirent.name)
          ),
        };
        console.log("\n\n Result", result);
        // itemsList.push({
        //   title:
        //     indexFileData?.frontmatter?.title ||
        //     indexFileData?.headings[0]?.value,
        //   path: indexFileData?.path,
        //   children: getItemsFromDir(
        //     path.join(dirName, dirent.name, "index.mdx")
        //   ),
        // });

        // console.log("is dir", entity);

        // children = await getItemsFromDir(path.join(dirName, dirent.name));
      }

      if (isFile) {
        let markdown = await fs.readFile(entity, "utf8");

        const fileOfRemark: any = remark()
          .use(remarkFrontmatter, ["yaml", "toml"])
          .use(remarkParseFrontmatter)
          .use(remarkHeadings)
          .processSync(markdown);

        itemsList.push({
          path: getFullUrlPath(`/docs/${dirName}/${dirent.name}`),
          title:
            fileOfRemark.data?.frontmatter?.title ||
            fileOfRemark.data?.headings?.find((item: any) => item.depth === 1)
              ?.value,
          children: [],
        });
        continue;
      }

      // const integration: Integration = {
      //   name: dirent.name,
      //   path: dirent.name,
      //   docs: [],
      //   metadata: null,
      // };

      // fs.readdirSync(integrationDir).flatMap(async (x) => {
      //   const filePath = path.join(integrationDir, x);

      //   // Ignore index files, folders and non-markdown files
      //   const isFile = fs.lstatSync(filePath).isFile();
      //   if (!isFile || x.indexOf(".md") < 0) {
      //     return;
      //   }

      //   // Parse markdown
      //   const fileContent = fs.readFileSync(filePath).toString();

      //   // With Remark, which is built on top of Unified, basically by adding remarkParse and remarkStringify.

      //   const fileOfRemark = remark()
      //     .use(remarkFrontmatter, ["yaml", "toml"])
      //     .use(remarkParseFrontmatter)
      //     .processSync(fileContent);

      //   // Add file details as metadata information on integration
      //   if (x === "index.mdx") {
      //     integration.metadata = fileOfRemark.data.frontmatter;
      //     return;
      //   }

      //   const pathOfX = fileToPath(x);

      //   // Add file details as doc on integration
      //   integration.docs.push({
      //     // clean up things like .md
      //     path: path.join(plainPathString, "integrations", pathOfX),
      //     ...fileOfRemark.data,
      //   });
      // });

      // integrationList.push(integration);
    }
  } catch (error) {
    console.error(`Error getting autogenerated items from dir ${dirName}:`);
  }

  return itemsList;

  // return integrationList.sort((a, b) => a.name.localeCompare(b.name));
}

export type SidebarItem = {
  title?: string;
  path?: string;
  children?: SidebarItem[];
  divider?: boolean;
  collapsible?: boolean;
};
const getItemFromString = async (
  itemPath: string
): Promise<SidebarItem | null> => {
  const data = await getSidebarItemAtPath(itemPath);
  if (!data) {
    throw new Error(`No file found for sidebar item: ${itemPath}`);
  }

  return {
    path: data.path,
    title:
      data.frontmatter?.title ||
      data.headings.find((item: any) => item.depth === 1)?.value,
    children: [],
  };
};

const getChildrenData = async (childItems: any, parentPath: string | null) => {
  return Promise.allSettled(
    childItems.map(async (child: string | any) => {
      const childType = typeof child;
      switch (childType) {
        case "string":
          return await getItemFromString(child);
        case "object":
          if (child?.type === "autogenerated") {
            return await getItemsFromDir(child.dirName);
          }
          return await getItemFromObject(child);
      }
    })
  );
};

const getItemFromObject = async (docusaurusObject: any) => {
  const path = docusaurusObject?.link?.id
    ? "/docs/" + docusaurusObject.link.id.split("/index")[0]
    : null;
  const childrenData = await getChildrenData(
    docusaurusObject.items,
    // dirName applies to items with autogenerated children
    path || docusaurusObject?.dirName
  );

  return {
    title: docusaurusObject.label,
    path,
    // children: [],
    children: !docusaurusObject.items
      ? []
      : childrenData.map((item: any) => item.value),
    collapsible:
      docusaurusObject.collapsible !== undefined
        ? docusaurusObject.collapsible
        : true,
  };
};

/**
 * Make this just work if the item is formatted properly already
 */
export const getSidebar = async () => {
  return Promise.allSettled(
    docusaurusSidebar.map(async (navItem: any) => {
      if (typeof navItem === "string") {
        return await getItemFromString(navItem);
      }
      if (navItem.type === "html") {
        return {
          title: navItem.value,
          divider: true,
        };
      }
      return await getItemFromObject(navItem);
    })
  );
};
