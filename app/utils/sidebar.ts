import fs from "fs/promises";
import path from "path";
import { getSidebarItemAtPath } from "./getSidebarData";
import { AutogeneratedSidebarGroup, navData, SidebarGroup } from "./navData";
import remarkHeadings from "@vcarl/remark-headings";
import { remark } from "remark";
import remarkFrontmatter from "remark-frontmatter";
import remarkParseFrontmatter from "remark-parse-frontmatter";
import { getFullUrlPath } from "./pathSanitization";
import { titleCase } from "title-case";
import { doesIncludeNormalizedPath, doNormalizedPathsMatch } from "./redirects/pathMethods";

export type SidebarItemData = {
  title: string;
  path?: string;
  children?: SidebarItemData[];
  isAutoGenerated?: boolean;
  collapsible?: boolean; // If true, this item can be collapsed in the sidebar
  subDirsCollapsible?: boolean; // If true, all subdirectories can be collapsed
  frontmatter?: any;
};

/**
 * If no index data, path, title, etc can be pulled from the parent object
 */

export async function getItemsFromDir(dirName: string, collapsible: boolean = false): Promise<SidebarItemData[]> {  
  const remixPathString = "./app/routes/docs+";
  const pathWithPlusesInside = dirName.replaceAll(/(?<!\+)\//g, '+/');
  const adjustedDirName = pathWithPlusesInside.endsWith("+") || pathWithPlusesInside.endsWith("+/") ?
    pathWithPlusesInside : `${pathWithPlusesInside}+`;
  const itemsDir = path.join(process.cwd(), remixPathString, adjustedDirName);
  const itemsList: SidebarItemData[] = [];

  try {

    const dir = await fs.opendir(itemsDir);
    for await (const dirent of dir) {
			if (dirent.name.startsWith("_")) {
				// Skip hidden items
        continue;
			}

      const entity = path.join(itemsDir, dirent.name);
      const isFile = (await fs.lstat(entity)).isFile();

      if (!isFile) {   
        const indexFilePath = path.join(
          `${dirName}+/`,
          `${dirent.name}+/`,
          "index"
        );
        const indexFileData = await getSidebarItemAtPath(indexFilePath);
        const children: any[] | any = await getItemsFromDir(
          path.join(adjustedDirName, dirent.name),
          collapsible
        );

        const filteredChildren = children?.filter(
          (item: any) => item?.path && !item?.path?.includes("index")
        );

        if(!indexFileData && filteredChildren.length === 0) {
          // If no index file and no children, skip this directory
          console.error(`Failed to add empty directory ${dirent.name} to sidebar. To be in the sidebar, a directory must have a file or subdirectory with a file.`);
          continue;
        }

        itemsList.push({
          title: !indexFileData ? titleCase(dirent.name.split("+/").pop()?.replaceAll("-", " ").replaceAll("+", "") || "") || "" :
            indexFileData.frontmatter?.sidebar_label ||
            indexFileData.frontmatter?.title ||
            indexFileData.headings[0]?.value || "",
          frontmatter: indexFileData?.frontmatter,
          path: !indexFileData ? "" : getFullUrlPath(indexFileData.path),
          children: filteredChildren,
          collapsible,
        });
        continue;
      }
     
      if(!entity.endsWith(".md") && !entity.endsWith(".mdx")) {
        // Skip non-md/mdx files
        continue;
      }
      
      let markdown = await fs.readFile(entity, "utf8");

      const fileOfRemark: any = remark()
        .use(remarkFrontmatter, ["yaml", "toml"])
        .use(remarkParseFrontmatter)
        .use(remarkHeadings)
        .processSync(markdown);

      itemsList.push({
        path: getFullUrlPath(`/docs/${dirName}/${dirent.name}`),
        title:
          fileOfRemark.data?.frontmatter?.sidebar_label ||
          fileOfRemark.data?.frontmatter?.title ||
          fileOfRemark.data?.headings?.find((item: any) => item.depth === 1)
            ?.value,
        frontmatter: fileOfRemark.data?.frontmatter,
        children: [],
      });
    }
  } catch (error) {
    // It's a file, not a directory
    return itemsList;
    // console.error(
    //   `Error getting autogenerated items from dir ${itemsDir}:`,
    //   error
    // );
  }
  
      
  return itemsList;

  // return integrationList.sort((a, b) => a.name.localeCompare(b.name));
}

const getItemFromString = async (
  itemPath: string
): Promise<SidebarItemData | null> => {
  const data = await getSidebarItemAtPath(itemPath);
  if (!data) {
    throw new Error(`No file found for sidebar item: ${itemPath}`);
  }

  return {
    path: getFullUrlPath(data.path),
    title:
      data.frontmatter?.sidebar_label ||
      data.frontmatter?.title ||
      data.headings.find((item: any) => item.depth === 1)?.value,
    frontmatter: data.frontmatter,
    children: [],
  };
};

const getChildrenData = async (itemData: any) => {
  if(!itemData || !itemData.items || itemData.items.length === 0) {
    return [];
  }
  return Promise.allSettled(
    itemData.items.map(async (childData:  any) => {
      const childType = typeof childData;
      switch (childType) {
        case "string":
          return await getItemFromString(childData as string);
        case "object":
          const collapsible = Boolean(itemData.subDirsCollapsible ?? childData.collapsible);
          if (childData?.type === "autogenerated") {      
            return await getItemsFromDir(childData.dirName, collapsible);
          }
          return await getItemFromObject({...childData, collapsible});
      }
    })
  );
};

const getItemFromObject = async (itemData: any) => {
  let path = "";
  switch(itemData.type) {
    case "link":
      path = itemData?.href || null;
      break;
    default: // "doc" or "category"
      const id = itemData?.link?.id || itemData?.id;
      if(id){
        path = `/docs/${id.split("/index")[0]}`;
      }
      break;
  }
    
  const childrenData = itemData.items ? await getChildrenData(
    itemData
  ) : [];

  const children = childrenData?.map((item: any) => item.value).flat();

  return {
    ...itemData,
    title: itemData.label,
    path: getFullUrlPath(path) || getFullUrlPath(children?.[0]?.path) || "",
    children,
  };
};

/**
 * Make this just work if the item is formatted properly already
 */
export const getSidebar = async () => {
  return Promise.allSettled(
    navData.map(async (topLevelBucket: any) => {
      if (typeof topLevelBucket !== "object") throw new Error("Top-level nav item must be an object");
      return await getItemFromObject(topLevelBucket);
    })
  );
};

function findInNestedArray(children: any, path: string) {
  if(!children) return null;
  for (const item of children) {
    if(!item){
      // console.log("Item is null or undefined", path, item);
      continue;
    }

    if(item["path"]){
      if (doNormalizedPathsMatch(path, item["path"])) {
        return item;
      }
    }
    // Recurse if children `ex`ist and are an array
    if (Array.isArray(item["children"])) {
      const found: SidebarItemData = findInNestedArray(item["children"], path);
      if (found) {
        return found;
      }
    }
  }

  return null;
}

export const getActiveNavBucket = (windowPath: string, sidebarData: SidebarItemData[]) => {
  // First check if the window path is one of the top-level pages
  const topLevelPage =  sidebarData.find((item: SidebarItemData) => doNormalizedPathsMatch(item.path, windowPath) || doesIncludeNormalizedPath(windowPath, item.path));
  if(topLevelPage) return topLevelPage;

  // If not, find the first bucket that has a child with the current path
  return sidebarData.find((bucket: SidebarItemData) => {
    return findInNestedArray(bucket.children, windowPath);
  });
}
